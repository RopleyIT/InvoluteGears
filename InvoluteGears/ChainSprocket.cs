using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json.Serialization.Metadata;
using System.Xml.Schema;
using TwoDimensionLib;

namespace InvoluteGears;

public class ChainSprocket : IGearProfile
{
    public ChainSprocket(int teeth, double wire, double err, double inner, double outer, double cutDiameter, double backlash)
    {
        ToothCount = teeth;
        WireThickness = wire;
        OuterLinkWidth = outer;
        MaxError = err;
        Backlash = backlash;
        InnerLinkLength = inner;
        CutDiameter = cutDiameter;
        Errors = String.Empty;
        Information = SetInformation();
        //var curves = CalculatePoints();
        //OuterToothProfile = Geometry.LinearReduction
        //    (curves.outer, MaxError);
        //InnerToothProfile = Geometry.LinearReduction
        //    (curves.inner, MaxError);
    }

    private string SetInformation()
    {
        var info = $"Sprocket: {ToothCount} teeth, link thickness = {WireThickness}mm\r\n";
        info += $"precision = {MaxError}mm, inner length = {InnerLinkLength}mm\r\n";
        info += $"outer width = {OuterLinkWidth}mm, backlash = {Backlash}mm\r\n";
        return info;
    }

    public string ShortName
        => $"St{ToothCount}w{WireThickness:N2}e{MaxError:N2}i{InnerLinkLength:N2}o{OuterLinkWidth:N2}b{Backlash:N2}";

    public string Information { get; private set; }

    /// <summary>
    /// Error messages generated by the gear generators. If an
    /// empty string, the gear generation has succeeded and the
    /// other fields will contain data. If non-empty the other
    /// fields may be empty or null.
    /// </summary>

    public string Errors { get; private set; }

    /// <summary>
    /// A count of the number of chain links around the sprocket
    /// divided by two. Note this is because we are counting the
    /// links that are parallel to the surface of the sprocket,
    /// not the alternate ones that are normal to it.
    /// </summary>

    public int ToothCount { get; private set; }

    public double ToothAngle
        => 2 * Math.PI / ToothCount;

    /// <summary>
    /// The distance across the width of a chain link
    /// including the thickness of the link wire
    /// </summary>

    public double OuterLinkWidth { get; private set; }

    /// <summary>
    /// The length of the opening in the middle of a
    /// chain link, measured between the inner ends
    /// of a link
    /// </summary>

    public double InnerLinkLength { get; private set; }

    /// <summary>
    /// The diameter of the wire used to make each
    /// chain link, asssumed to be cylindrical
    /// </summary>

    public double WireThickness { get; private set; }

    /// <summary>
    /// The tolerance in precision for cutting the sprocket
    /// </summary>

    public double MaxError { get; private set; }

    /// <summary>
    /// Loosening of the sprocket to allow for
    /// variation in chain link dimensions.
    /// Manifests itself as longer grooves where
    /// the coplanar links bed into the edge of
    /// the sprocket.
    /// </summary>

    public double Backlash { get; private set; }

    /// <summary>
    /// The diameter of the cutter bit used to cut out
    /// the sprocket shape
    /// </summary>

    public double CutDiameter { get; private set; }

    /// <summary>
    /// Sprockets are not designed by setting their module.
    /// Instead they are designed from the dimensions of
    /// each chain link. However the module is used to compute
    /// the spoke thicknesses, so set a value notionally
    /// based on the diameter and number of chain links
    /// </summary>

    public double Module { get; private set; }

    /// <summary>
    /// Sprockets do not have a meaningful interpretation
    /// of an inner diameter. However, it is taken to be
    /// twice the distance from the centre of the sprocket
    /// to the nearest groove point on the X axis.
    /// </summary>

    public double InnerDiameter { get; private set; }

    /// <summary>
    /// For a chain sprocket, this is taken to be the distance
    /// from the sprocket centre to the intersection of the line
    /// of centres between two adjacent chain links
    /// </summary>

    public double PitchRadius { get; private set; }

    private static double Sqr(double x) => x * x;

    private (List<Coordinate> outer, List<Coordinate> inner) CalculatePoints()
    {
        // Calculate the inside radius of one end of a link,
        // the two distances for the unequal faces of the
        // polygon that is the profile for the curvature of
        // the chain links around the sprocket, and the angle
        // between two adjacent links in the chain

        double r = OuterLinkWidth / 2 - WireThickness;
        double a = InnerLinkLength + 2 * r;
        double b = InnerLinkLength - 2 * r;
        double C = Math.PI * (ToothCount - 1) / (double)ToothCount;

        // Use the cosine rule to find the distance between
        // adjacent pairs of links

        double lSquared = Sqr(a);
        lSquared += Sqr(b);
        lSquared -= 2 * a * b * Math.Cos(C);
        double l = Math.Sqrt(lSquared);

        // Find the other two angles, A and B at the other two
        // corners of the same triangle

        // double A = Math.Acos((lSquared + a * a - b * b) / (2 * l * a));
        // double B = Math.PI - A - C;

        // Now compute the radius from the centre of the
        // sprocket to one end of the line between adjacent
        // pairs of links

        PitchRadius = l / (2 * Math.Sin(Math.PI / ToothCount));

        // We shall set the origin at the centre of the sprocket. The
        // point in the middle of a link that is parallel to the
        // plane of the sprocket lies on the X axis, the link being
        // parallel to the Y axis. T is the centre of the semicircle
        // formed by one end of the link

        Coordinate t = new(
            Geometry.RootDiffOfSquares(PitchRadius, b / 2), b / 2);

        // C is the centre of the wire for the next link, lying on a
        // line from T in the direction of the 3rd link

        double sinTooth = Math.Sin(Math.PI / ToothCount);
        double cosTooth = Math.Cos(Math.PI / ToothCount);

        Coordinate c = new(
            t.X - (r - WireThickness / 2) * sinTooth,
            t.Y + (r - WireThickness / 2) * cosTooth);

        // U is the point on the second link parallel to the X
        // axis, closest to the centre of the first link.
        // V is the point on the second link just past its
        // curvature due to the wire thickness, where it
        // becomes parallel to the diagonal face of the sprocket
        // beyond the first link.

        Coordinate u = new(c.X, c.Y - WireThickness / 2);
        double arcAngle;
        double arcRadius = CutDiameter / 2; // Assume cutter bigger than wire
        Coordinate convexCtr;

        // Find length to mid point of face on which
        // perpendicular link lies

        double oz = Geometry
            .RootDiffOfSquares(PitchRadius, a / 2) - WireThickness / 2;
        Coordinate z = new(oz * cosTooth, oz * sinTooth);

        if (WireThickness >= CutDiameter)
        {
            arcRadius = WireThickness / 2;
            // v = Involutes.CreatePt(
            //    c.X - arcRadius * cosTooth,
            //    c.Y - arcRadius * sinTooth);
            arcAngle = Math.PI * (0.5 - 1.0 / ToothCount);
            convexCtr = c;
        }
        else
        {
            // Coordinate of cutter centre when cutting corner
            // between parallel and perpendicular links

            convexCtr = new(u.X, u.Y + arcRadius);

            // Find the distance from the cutter centre to the sloping face

            double cPerp = u.X * cosTooth - oz + sinTooth * (u.Y + arcRadius);

            // Find the angle from the perpendicular to the intersection point

            arcAngle = Math.Acos(cPerp / arcRadius)
                + Math.PI / 2 - Math.PI / ToothCount;
        }

        // Now plot one chain link worth of profile

        List<Coordinate> points = new()
        {
            new Coordinate(t.X + OuterLinkWidth / 2, 0)
        };
        Coordinate cUpper = new(t.X, u.Y - OuterLinkWidth / 2);
        points.AddRange(Geometry.CirclePoints(
            0, Math.PI / 2, Math.PI / 180, OuterLinkWidth / 2, cUpper));
        points.AddRange(Geometry.CirclePoints(
            1.5 * Math.PI - arcAngle, 1.5 * Math.PI, Math.PI / 180, arcRadius, convexCtr)
            .Reverse());
        points.Add(z);

        // Now calculate the recess profile

        double grooveStartAngle = Math.Acos(WireThickness / OuterLinkWidth);
        grooveStartAngle = Math.PI * (1.0 + ToothCount) / ToothCount
            - grooveStartAngle;

        Coordinate bt = new(t.X - Backlash * sinTooth, t.Y + Backlash * cosTooth);
        List<Coordinate> groovePoints = new();
        InnerDiameter = 2 * t.X - OuterLinkWidth;
        Module = InnerDiameter / ToothCount;
        groovePoints.Add(new Coordinate(InnerDiameter / 2 - Backlash * sinTooth, 0));
        groovePoints.AddRange(Geometry.CirclePoints(
            grooveStartAngle, Math.PI, Math.PI / 180, OuterLinkWidth / 2, bt)
            .Reverse());
        groovePoints.Add(z);
        return (points, groovePoints);
    }

    private readonly IList<Coordinate>? OuterToothProfile = null;
    private readonly IList<Coordinate>? InnerToothProfile = null;


    /// <summary>
    /// Generate the sequence of points describing the
    /// shape of a single tooth profile
    /// </summary>
    /// <param name="gap">Which tooth profile we want.
    /// For gap = 0, we generate the tooth whose
    /// tip lies on the positive X axis. Teeth rotate
    /// anticlockwise from there for increasing
    /// values of gap.</param>
    /// <returns>The set of points describing the
    /// profile of the selected tooth.</returns>

    private IEnumerable<Coordinate> ToothProfile(int gap, bool outer)
    {
        IList<Coordinate>? profile = outer ? OuterToothProfile : InnerToothProfile;
        double angle = 2 * Math.PI * (gap % ToothCount) / (double)ToothCount;
        if (profile == null)
            return Enumerable.Empty<Coordinate>();
        else
            return
                profile
                .Skip(1)
                .Reverse()
                //.Skip(1)
                .Select(p => p.Conjugate)
                .Concat(profile)
                .Select(p => p.Rotate(angle));
    }

    /// <summary>
    /// Generate the complete path of
    /// points for the whole sprocket outer edge
    /// </summary>
    /// <returns>The set of points describing the sprocket outer edge
    /// </returns>

    private IEnumerable<Coordinate> GenerateCompleteGearPath() => Enumerable
            .Range(0, ToothCount)
            .Select(i => ToothProfile(i, true))
            .SelectMany(p => p);

    /// <summary>
    /// Generate the complete path of
    /// points for the whole sprocket inner groove
    /// </summary>
    /// <returns>The set of points describing the sprocket groove
    /// </returns>

    public IEnumerable<Coordinate> GenerateInnerGearPath() => Enumerable
            .Range(0, ToothCount)
            .Select(i => ToothProfile(i, false))
            .SelectMany(p => p);

    public DrawableSet GenerateGearCurves() =>
        new()
        {
            Paths = new List<DrawablePath>
            {
                PinProfile(), // Temporary to test shoulder profile
                ShoulderProfile(),
                RimProfile()
            }
        };

    public DrawablePath GenerateInnerGearCurve()
        => new()
        {
            Curves = new List<IDrawable>
            {
                new PolyLine
                {
                    Vertices = GenerateInnerGearPath().ToList()
                }
            },
            Closed = true
        };

    // New functions
    //
    // A chain has wire links made of two semicircles joined by two
    // parallel straight wires from their tips. The inside length
    // of the links is InnerLinkLength. The outside width of a link
    // across the parallel sides is OuterLinkWidth. The diameter of
    // the wire is WireThickness. The number of links around each
    // sprocket is ToothCount, but given alternate links are normal
    // then coplanar with the plane of the sprocket, the tooth
    // pattern around the gear repeats ToothCount/2 times.
    //
    // We assume a link is pulled on the sprocket so that the plane
    // in which it lies includes the centre of curvature for the
    // semicircular end of the next link, whose plane is normal to
    // the plane of the first link.

    double normalRadius = 0;    // Distance from centre of sprocket to
                                // centreline of link that lies at
                                // right angles to the plane of gear
    double innerArcRadius= 0;   // Radius of arc drawn beneath the
                                // coplanar link as a recess for it
    Coordinate innerArcCentre;  // Centre of the inner arc

    /// <summary>
    /// Generate the closed path for the wheel rim
    /// at layers 1 and 5 of the chain sprocket
    /// </summary>
    /// <returns>The path for the circular rime</returns>
    
    private DrawablePath RimProfile()
    {
        double n = (InnerLinkLength + OuterLinkWidth) / 2 - WireThickness;
        double m = (InnerLinkLength - OuterLinkWidth) / 2 + WireThickness;
        double cosTooth = Math.Cos(ToothAngle/2);
        double sinTooth = Math.Sin(ToothAngle/2);
        normalRadius = (m + n * cosTooth) / sinTooth;
        double rimRadius = Geometry.RootDiffOfSquares(normalRadius, n) 
            + OuterLinkWidth / 2;
        return CircularArc.Circle(rimRadius);
    }

    /// <summary>
    /// Generate an entire gear path for the
    /// shoulder part of the chain sprocket,
    /// which forms layers 2 and 4 of the gear
    /// </summary>
    /// <returns>A drawable closed path for the
    /// pin part of the sprocket</returns>

    private DrawablePath ShoulderProfile()
    {
        IList<IDrawable> oneShoulder = OneShoulderProfile();
        DrawablePath profile = new DrawablePath
        {
            Closed = true,
            Curves = new List<IDrawable>()
        };
        for (int i = 0; i < ToothCount; i++)
        {
            profile.Curves.AddRange
                (oneShoulder.Select(d => d.RotatedBy
                    (i * ToothAngle, Coordinate.Empty)));
        }
        return profile;
    }

    /// <summary>
    /// Compute the shape of the first shoulder profile. A gear
    /// is made up of an outer rim at layers 1 and 5, shoulders
    /// at layers 2 and 4, and pins at layer 3.
    /// </summary>
    /// <returns>The template for the first shoulder. Should
    /// be replicated every 2 Pi / ToothCount around the 
    /// circumference. Note that ToothCount is half the number
    /// of links around the gear as there is a tooth every
    /// alternate link.
    /// </returns>

    private IList<IDrawable> OneShoulderProfile()
    {
        double n = (InnerLinkLength + OuterLinkWidth) / 2 - WireThickness;
        double m = (InnerLinkLength - OuterLinkWidth) / 2 + WireThickness;
        double cosTooth = Math.Cos(ToothAngle/2);
        double sinTooth = Math.Sin(ToothAngle/2);
        normalRadius = (m + n * cosTooth) / sinTooth;
        innerArcRadius = m/cosTooth + OuterLinkWidth/2 + Backlash/2;
        innerArcCentre = new()
        {
            X = normalRadius,
            Y = normalRadius * sinTooth / cosTooth
        };
        double arcAngleOffset = Math.Asin(WireThickness/(2*innerArcRadius));
        double innerArcStartAngle = 1.5 * Math.PI - arcAngleOffset;
        double innerArcEndAngle = 0.5 * Math.PI + ToothAngle + arcAngleOffset;
        Coordinate endOfFlat = innerArcCentre 
            + Coordinate.FromPolar(innerArcRadius, innerArcStartAngle);
        Coordinate startOfFlat = endOfFlat.Conjugate;

        // Now use the data to generate one tooth of the gear
        // profile for the shoulder layers of the gear

        return new List<IDrawable>
        {
            new Line(startOfFlat, endOfFlat),
            new CircularArc
            {
                Anticlockwise = false,
                Centre = innerArcCentre,
                StartAngle = innerArcStartAngle,
                EndAngle = innerArcEndAngle,
                Radius = innerArcRadius
            }
        };
    }

    /// <summary>
    /// Generate an entire gear path for the
    /// pin part of the chain sprocket. This
    /// is the middle (3rd) layer of the gear.
    /// </summary>
    /// <returns>A drawable closed path for the
    /// pin part of the sprocket</returns>
    
    private DrawablePath PinProfile()
    {
        IList<IDrawable> onePin = OnePinProfile();
        DrawablePath profile = new DrawablePath
        {
            Closed = true,
            Curves = new List<IDrawable>()
        };
        for(int i = 0; i < ToothCount; i++)
        {
            profile.Curves.AddRange
                (onePin.Select(d => d.RotatedBy
                    (i * ToothAngle, Coordinate.Empty)));
        }
        return profile;
    }

    /// <summary>
    /// Compute the shape of the middle pin gear profile. A gear
    /// is made up of an outer rim at layers 1 and 5, shoulders
    /// at layers 2 and 4, and pins at layer 3.
    /// </summary>
    /// <returns>The template for the middle pin wheel. Should
    /// be replicated every 4 Pi / N around the circumference
    /// </returns>
    /// <exception cref="ArgumentException">Chain sprockets
    /// must have an even tooth count. Thrown if the tooth
    /// count is odd.</exception>
    
    private IList<IDrawable> OnePinProfile()
    {
        double n = (InnerLinkLength + OuterLinkWidth) / 2 - WireThickness;
        double m = (InnerLinkLength - OuterLinkWidth) / 2 + WireThickness;
        double cosTooth = Math.Cos(ToothAngle / 2);
        double sinTooth = Math.Sin(ToothAngle / 2);
        normalRadius = (m + n * cosTooth) / sinTooth;
        innerArcRadius = m / cosTooth + OuterLinkWidth / 2 + Backlash / 2;
        innerArcCentre = new()
        {
            X = normalRadius,
            Y = normalRadius * sinTooth / cosTooth
        };
        double innerArcStartAngle = 1.5 * Math.PI;
        double innerArcEndAngle = 0.5 * Math.PI + ToothAngle;

        IList<IDrawable> segments = new List<IDrawable>();

        // The pin or tooth should just glide inside the normal
        // link as the chain wraps/unwraps from the wheel. It is
        // assumed that the links slide frictionlessly in the
        // loop at the end of each link. Backlash should be set
        // to accommodate the tighter turning angle caused by
        // friction. The pin is shaped of a sequence of circular
        // segments that get a larger radius and a different
        // centre of curvature as each successive link begins
        // to unwrap from the gear.

        bool done = false;
        // Radius of the curved face of the tooth
        double radius = -(OuterLinkWidth + Backlash) / 2;
        // Distance from gear centre to centre of
        // curvature for the tooth face
        double cornerRadius = Geometry
            .RootSumOfSquares(normalRadius, n);
        double cornerAngle = Math.Atan2(n, normalRadius);
        Coordinate curveCtr;
        for(int i = 0; !done; i++)
        {
            double sa = i * ToothAngle/2 - Math.PI / 2;
            double ea = sa + ToothAngle/2;
            bool odd = (i & 1) != 0;
            if (odd)
            {
                radius += 2*m;
                curveCtr = Coordinate.FromPolar
                    (cornerRadius, (i + 1) * ToothAngle/2 - cornerAngle);
            }
            else
            {
                radius += 2*n;
                curveCtr = Coordinate.FromPolar
                    (cornerRadius, i * ToothAngle/2 + cornerAngle);
            }

            // Check to see if the end of the compound tooth arc
            // lies in this curve segment. We calculate the angle
            // from the current curve centre to the Y=0 axis.

            double crossingAngle = Math.Asin(-curveCtr.Y / radius);
            if(crossingAngle < ea)
            {
                done = true;
                ea = crossingAngle;
            }

            segments.Add(new CircularArc
            {
                Anticlockwise = true,
                Centre = curveCtr,
                StartAngle = sa,
                EndAngle = ea,
                Radius = radius
            });
        }

        // Construct the other side of the tooth

        IList<IDrawable> otherSideOfTooth = segments
            .Reverse()
            .Select(d => d.ReflectY().Reversed())
            .ToList();

        segments.AddRange(otherSideOfTooth);

        // Generate the valley in which one side of the
        // coplanar link sits when wrapped around the gear

        segments.Add(new CircularArc
        {
            Anticlockwise = false,
            Centre = innerArcCentre,
            StartAngle = innerArcStartAngle,
            EndAngle = innerArcEndAngle,
            Radius = innerArcRadius
        });

        return segments;
    }
}
