using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection.Metadata;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using TwoDimensionLib;

namespace InvoluteGears;

public class InvoluteGearParameters : IGearProfile
{
    public InvoluteGearParameters(int toothCount, double module = 1.0,
        double pressureAngle = Math.PI / 9, double profileShift = 0.0,
        double maxErr = 0.0, double backlash = 0.0, double cutterDiam = 0.0)
    {
        linesOnly = false; // Set true to force drawing using short line segments
        ToothCount = toothCount;
        Module = module;
        PressureAngle = pressureAngle;
        ProfileShift = profileShift;
        MaxError = maxErr;
        Backlash = backlash;
        CutDiameter = cutterDiam;
        Errors = String.Empty;
        Information = SetInformation();
        InitPointLists();
    }

    private string SetInformation()
    {
        StringBuilder info = new();
        info.Append($"Involute: {ToothCount} teeth, module = {Module}mm, pressure angle = {PressureAngle * 180 / Math.PI:N1}\u00b0\r\n");
        info.Append($"profile shift = {ProfileShift * 100:N1}%, precision = {MaxError}mm\r\n");
        info.Append($"backlash = {Backlash * Module}mm, cutter diameter = {CutDiameter}mm\r\n");
        return info.ToString();
    }

    public string ShortName
        => $"It{ToothCount}m{Module:N2}a{PressureAngle * 180 / Math.PI:N1}s{ProfileShift:N3}"
            + $"e{MaxError:N2}b{Backlash * Module:N2}c{CutDiameter:N2}";

    /// <summary>
    /// Used for warning or information messages when methods invoked
    /// </summary>

    public string Information { get; private set; }

    /// <summary>
    /// Error messages generated by the gear generators. If an
    /// empty string, the gear generation has succeeded and the
    /// other fields will contain data. If non-empty the other
    /// fields may be empty or null.
    /// </summary>

    public string Errors { get; private set; }

    /// <summary>
    /// The diameter of the bit used to cut out the gear. In mm.
    /// </summary>

    public double CutDiameter
    {
        get;
        private set;
    }

    /// <summary>
    /// The tolerance for the curved faces of the teeth. This is used to set the
    /// maximum deviation of the points on the curved faces from true value, and
    /// is used to reduce the number of points we plot on each curve. Default
    /// of zero does no reduction. Should be set to a value that matches the
    /// precision of the cutting machine for the gears. Measured in mm.
    /// </summary>

    public double MaxError { get; private set; }

    /// <summary>
    /// The amount of backlash to build into the gear. If left at zero,
    /// theoretically perfect gear surfaces are created, for which the leading
    /// and trailing faces rub against each other with zero gap. By setting
    /// a value for this, we build in a small angular separation between
    /// the trailing face of one tooth and the leading edge of the tooth
    /// behind. We also shorten the tooth addendum radius slightly, while
    /// still computing the undercut for the tooth at full addendum
    /// height. This fractionally reduces the contact ratio, but only
    /// for the larger tooth counts where the full length of the 
    /// involute surface of the tooth might be used. In these cases
    /// the contact ratio is high anyway. In fact, for low tooth
    /// counts, shortening the addendum height actually reduces
    /// undercut if it were computed for the shortened tooth. Here
    /// though we still compute the undercut as if a full length tooth
    /// then shorten the tooth slightly to remove rubbing at the
    /// dedendum surface.
    /// Backlash is measured in fractions of the Module. This
    /// equates to the same fraction of the module for shortening
    /// of the addendum height. However, we don't multiply by PI
    /// circumferentially, we take the fraction of the module
    /// as measured at the pitch circle. Hence at the pitch
    /// circle for a backlash of 0.2 and a module of 5mm,
    /// both radially and circumferentially we would get a
    /// backlash of 1mm.
    /// </summary>

    public double Backlash { get; private set; }

    /// <summary>
    /// The profile shift coefficient for corrected gears.
    /// Used to keep the contact ratio above 1.0 for gears
    /// with numbers of teeth fewer than 17. This figure
    /// is multiplied by the Module to find how far the
    /// dedendum and addendum radii are increased. Hence
    /// it has units of fractions of the module.
    /// </summary>

    public double ProfileShift { get; private set; }

    /// <summary>
    /// Two gears that are engaged with each other each
    /// have a pitch circle. The pitch circles of the
    /// two gears are tangential to each other and have
    /// radii that are in the same ratio as the gear
    /// ratio between the two gears.
    /// </summary>

    public double PitchCircleDiameter => Module * ToothCount;

    /// <summary>
    /// The radius of the gear including the projection
    /// of teeth by one module beyond the pitch circle.
    /// Adjustments are also made if the gear has been 
    /// profile shifted, and if the tooth has been 
    /// shortened for backlash (to prevent the addendum
    /// of one tooth grinding on the dedendum of its
    /// partner)
    /// </summary>

    public double AddendumCircleDiameter
        => PitchCircleDiameter
        + 2 * Module * (1 + ProfileShift - Backlash);

    /// <summary>
    /// Return the pitch radius, adjusted for any profile shift
    /// that has been applied to the gear
    /// </summary>
    
    public double PitchRadius
        => PitchCircleDiameter / 2 + Module * ProfileShift;

    /// <summary>
    /// The maximum non-interfering radius of the inner
    /// circle at the foot of the gap between teeth.
    /// Allowance has been made for profile shifting
    /// of the teeth.
    /// </summary>

    public double DedendumCircleDiameter
        => PitchCircleDiameter - 2 * Module
        * (1 - ProfileShift);

    private double? cutterAdjustedDedendumCircleDiameter;

    /// <summary>
    /// When we are using an end mill to cut out the teeth,
    /// there will be a minimum diameter for concave curves
    /// as they cannot be less than the diameter of the
    /// cutter. As a consequence, the shape of the dedendum
    /// can be modified to allow for the cutter diameter,
    /// meaning that the dedendum may dig deeper into the
    /// gear, but with shallower turns.
    /// </summary>

    public double InnerDiameter
    {
        get
        {
            if (cutterAdjustedDedendumCircleDiameter.HasValue)
                return cutterAdjustedDedendumCircleDiameter.Value;
            else
                return DedendumCircleDiameter;
        }
    }

    /// <summary>
    /// The number of teeth around the outside of the
    /// gear wheel. These are evenly spaced obviously.
    /// Note that if this is positive, it is a normal
    /// gear. If zero, it is a rack. If negative, it
    /// is an internal gear.
    /// </summary>

    public int ToothCount { get; private set; }

    /// <summary>
    /// The angle relative to a line between the centres
    /// of two gears at which the gears touch each other.
    /// By convention this is chosen to be 14.5, 20, or 25
    /// degrees, though there are no design reasons why
    /// these specific angles have to be used. Units are
    /// in radians, not degrees. 14.5 degrees = 0.25307
    /// radians. 20 degrees = 0.34907, and 25 degrees
    /// = 0.43633 radians.
    /// </summary>

    public double PressureAngle { get; private set; }

    /// <summary>
    /// The extra diameter needed per extra tooth for a
    /// given tooth width. In practice this value is often
    /// used to determine pitch circle diameter and tooth
    /// separation, rather than the other way round. Units
    /// in mm.
    /// </summary>

    public double Module { get; private set; }

    // -- DERIVED PROPERTIES -- //

    /// <summary>
    /// The base circle diameter for the involute curve
    /// </summary>

    public double BaseCircleDiameter
        => PitchCircleDiameter * Math.Cos(PressureAngle);

    /// <summary>
    /// The distance between adjacent teeth faces along
    /// the line of action, or the curved distance around
    /// the base circle between the start of the involutes
    /// for two adjacent teeth.
    /// </summary>

    public double BaseCirclePitch
        => Pitch * Math.Cos(PressureAngle);

    /// <summary>
    /// The distance between adjacent teeth around the pitch circle
    /// </summary>

    public double Pitch
        => Math.PI * Module;

    /// <summary>
    /// The angle from the pitch point to the point
    /// on the base circle at which its involute touches.
    /// At the pitch point two teeth are in contact at the
    /// pressure angle and at the point where the two pitch 
    /// circles meet. Two gears 'roll' on each other at the
    /// pitch circle, and the ratio between two pitch circle
    /// radii is used to derive the gear ratio. This point is
    /// Pi/(2*ToothCount) radians from the tooth centre. It is
    /// also PressureAngle radians from the point at which
    /// its involute through this contact point touches the
    /// base circle. Finally if the line from the pitch point
    /// were wrapped around the outside of the base circle,
    /// the point at which it ends would be at the angle we
    /// are interested in.
    /// </summary>

    private double ToothBaseOffset
        => Math.Tan(PressureAngle) - PressureAngle;

    /// <summary>
    /// The angle from the pitch point to the point on the
    /// addendum circle at which the involute touches.
    /// </summary>

    private double ToothTipOffset
        => AddendumInvoluteAngle
        - Math.Acos(BaseCircleDiameter / AddendumCircleDiameter)
        - ToothBaseOffset;

    /// <summary>
    /// The angle from the point at which a tooth involute touches
    /// the base circle to the point where the involute
    /// edge for the tooth reaches the addendum circle
    /// </summary>

    private double AddendumInvoluteAngle
        => Math.Sqrt(Geometry.Square(AddendumCircleDiameter / BaseCircleDiameter) - 1);

    /// <summary>
    /// The angle occupied by one tooth and one gap
    /// </summary>

    public double ToothAngle => 2 * Math.PI / ToothCount;

    /// <summary>
    /// The thickness of the tooth in radians
    /// measured at the pitch circle and
    /// allowing for possible profile shifting
    /// </summary>

    public double ToothWidthAngleAtPitchCircle
        => 2 * (Math.PI / 2 + 2 * ProfileShift * Math.Tan(PressureAngle)) / ToothCount;

    /// <summary>
    /// The thickness of the tooth gap in radians
    /// measured at the pitch circle and
    /// allowing for possible profile shifting
    /// </summary>

    public double GapWidthAngleAtPitchCircle
        => ToothAngle - ToothWidthAngleAtPitchCircle;

    /// <summary>
    /// A measurement of the distance across the tooth gap at its
    /// narrowest point, where the involute tooth edge meets the
    /// undercut trochoid. Does not include backlash widening.
    /// </summary>

    public double ToothGapAtUndercut =>
        2 * underCutPoint.Y;

    /// <summary>
    /// Calculate the square of the undercut radius
    /// </summary>

    private double SquaredUndercutRadius
        => Geometry.SumOfSquares(underCutPoint.X, underCutPoint.Y);

    /// <summary>
    /// Obtain the radius of the point at which the gear's
    /// involute working surface changes to the undercut
    /// trochoid. This is the point at which the gear teeth
    /// interaction no longer follows the involute curve.
    /// </summary>

    public double UndercutRadius => Math.Sqrt(SquaredUndercutRadius);

    /// <summary>
    /// Check that the two gears are compatible for meshing
    /// </summary>
    /// <param name="meshedGear">The other gear with which
    /// we are trying to mesh</param>
    /// <returns>True if the gears are compatible</returns>

    public bool CanMeshWith(InvoluteGearParameters meshedGear)
        => meshedGear != null
        && PressureAngle == meshedGear.PressureAngle
        && Module == meshedGear.Module;

    /// <summary>
    /// Given we are meshed with another gear where this and
    /// the other gear might have a profile shift, calculate
    /// the contact length for the two gears
    /// </summary>
    /// <param name="meshedGear">The gear with which we are
    /// meshed</param>
    /// <returns>The length of the path along which the two
    /// gears are in contact before breaking apart,
    /// then the distance between centres</returns>

    public (double, double) ContactDistanceWithGear(InvoluteGearParameters meshedGear)
    {
        if (!CanMeshWith(meshedGear))
        {
            Information = "Gears have differing modules or pressure angles";
            return (0, 0);
        }
        double distanceBetweenCentres
            = PitchCircleDiameter / 2
            + meshedGear.PitchCircleDiameter / 2
            + Module * (ProfileShift + meshedGear.ProfileShift);
        double distToPitchPoint = distanceBetweenCentres
            * BaseCircleDiameter / (BaseCircleDiameter + meshedGear.BaseCircleDiameter);
        double meshedDistToPitchPoint = distanceBetweenCentres - distToPitchPoint;

        // Calculate the maximum distance possible without
        // restriction on meshedGear addendum height

        double contactLength
            = Math.Sqrt(Geometry.DiffOfSquares(distToPitchPoint, BaseCircleDiameter / 2))
            - Math.Sqrt(SquaredUndercutRadius - Geometry.Square(BaseCircleDiameter / 2));

        // Now calculate the distance if the meshedGear addendum were
        // taken into account. Note that the actual contact distance
        // will be whichever of the two is smaller.

        double Q = Math.Asin(2 * meshedDistToPitchPoint 
            * Math.Cos(PressureAngle) / meshedGear.AddendumCircleDiameter);
        double addendumContactLength = meshedGear.AddendumCircleDiameter 
            / (2 * Math.Cos(PressureAngle)) 
            * Math.Sin(Math.PI / 2 - Q - PressureAngle);
        contactLength = Math.Min(contactLength, addendumContactLength);

        // Apply the same calculations to the other part of the contact line

        double meshedContactLength
            = Math.Sqrt(Geometry.DiffOfSquares(meshedDistToPitchPoint, meshedGear.BaseCircleDiameter / 2))
            - Math.Sqrt(meshedGear.SquaredUndercutRadius - Geometry.Square(meshedGear.BaseCircleDiameter / 2));
        Q = Math.Asin(2 * distToPitchPoint
            * Math.Cos(PressureAngle) / AddendumCircleDiameter);
        double meshedAddendumContactLength = AddendumCircleDiameter
            / (2 * Math.Cos(PressureAngle))
            * Math.Sin(Math.PI / 2 - Q - PressureAngle);
        meshedContactLength = Math.Min(meshedContactLength, meshedAddendumContactLength);

        return (contactLength + meshedContactLength, distanceBetweenCentres);
    }

    /// <summary>
    /// Contact ratio between two gears, allowing
    /// also for possible profile shift. Contact
    /// ratio is defined as the average number of
    /// teeth in contact between two gears as they
    /// rotate. If this is less than 1.0, there are
    /// times at which no teeth are meshing on the
    /// involute surfaces and the gears will
    /// vibrate or lock up.
    /// </summary>
    /// <param name="meshedGear">The other gear we
    /// are meshing with</param>
    /// <returns>The contact ratio. Must be greater
    /// than one for gears to mesh correctly.</returns>

    public (double, double) ContactRatioWith(InvoluteGearParameters meshedGear)
    {
        (double cr, double cd) = ContactDistanceWithGear(meshedGear);
        return (cr / BaseCirclePitch, cd);
    }

    /// <summary>
    /// Set to true to draw all curves as sequences of
    /// short lines. No gear contours are drawn using
    /// circular arcs, Bezier segments or other curves.
    /// </summary>
    
    private bool linesOnly = false;

    private IList<Coordinate>? UndercutPoints;
    private IList<Coordinate>? InvolutePoints;
    private IList<Coordinate>? DedendumPoints;
    private IList<Coordinate>? AddendumPoints;

    private IEnumerable<Coordinate> ComputeInvolutePoints()
    {
        // Angle away from centre of gap between teeth (X axis)
        // at which the involute touches the base circle.
        // This is because we calculate the gear to have a tooth
        // gap centred about the positive X axis.

        double involuteBaseAngle = GapWidthAngleAtPitchCircle / 2 - ToothBaseOffset;

        int limit = AngleIndexFloor(AddendumInvoluteAngle);
        for (int i = limit; i >= 0; i--)
        {
            double angle = (i % Geometry.PointsPerRotation) * Geometry.AngleStep;
            yield return Geometry.InvolutePlusOffset
                (BaseCircleDiameter / 2, 0, 0, angle, involuteBaseAngle);
        }
    }

    /// <summary>
    /// Find the angle that generated the coordinate at the specified
    /// index for the involute curve points
    /// </summary>
    /// <param name="index">The index into the involute points list
    /// for which we need the generating angle </param>
    /// <returns>The angle of the specified point</returns>
    
    private double InvoluteAngleFromIndex(int index)
    {
        double angle = GapWidthAngleAtPitchCircle / 2 - ToothBaseOffset;
        angle += AngleIndexFloor(AddendumInvoluteAngle);
        angle -= (index % Geometry.PointsPerRotation) * Geometry.AngleStep;
        return angle;
    }

    /// <summary>
    /// If the corner of the meshing tooth extends into the gear too
    /// far, as happens with gears containing fewer than about 17 teeth
    /// for pressure angles of 20 deg, undercutting of the tooth
    /// happens. This is because the corner of the meshing tooth
    /// follows the path of a prolate trochoid, i.e. one with a loop
    /// in it. Trochoids that are above the pitch circle follow the
    /// path of a curtate trochoid, where there is no loop, just a
    /// curved dip. When the corner meets the pitch circle exactly,
    /// the shape generated is a cycloid, with a sharp point touching
    /// the pitch circle.
    /// </summary>
    /// <returns>The list of coordinates spaced along the trochoid
    /// formed by the corner of the tooth</returns>

    private IEnumerable<Coordinate> ComputeUndercutPoints()
    {
        int lowerLimit = AngleIndexFloor(-UndercutAngleAtPitchCircle);
        int upperLimit = AngleIndexFloor(DedendumArcAngle / 2);
        for (int i = lowerLimit; i <= upperLimit; i++)
        {
            double angle = (i % Geometry.PointsPerRotation) * Geometry.AngleStep;
            yield return Geometry.InvolutePlusOffset(PitchCircleDiameter / 2,
                -Module * (1 - ProfileShift),
                Module * (Math.PI / 4 - Math.Tan(PressureAngle)), angle, 0);
        }
    }

    /// <summary>
    /// Find the angle that generated the coordinate at the specified
    /// index for the undercut curve points
    /// </summary>
    /// <param name="index">The index into the undercut trochoid points list
    /// for which we need the generating angle </param>
    /// <returns>The angle of the specified point</returns>

    public double UndercutAngleFromIndex(int index)
    {
        int indexBase = AngleIndexFloor(-UndercutAngleAtPitchCircle);
        return ((indexBase + index) % Geometry.PointsPerRotation) * Geometry.AngleStep;
    }

    /// <summary>
    /// Walk the list of undercut trochoid points and return the index of
    /// the last point in the list whose radius of curvature is greater
    /// than the radius of the end mill cutter.
    /// </summary>
    /// <returns>Index of last point that has big enough radius of
    /// curvature, or -1 if whole curve has large enough radius</returns>
    
    private int IndexOfLastUndercutPointWithSufficientRadius()
    {
        int i = 0;
        bool cornerFound = false;
        while (!cornerFound && i < UndercutPoints.Count - 2)
        {
            cornerFound = Geometry.RadiusOfCurvature
                (UndercutPoints[i], UndercutPoints[i + 1], UndercutPoints[i + 2]) 
                < CutDiameter / 2;
            i++;
        }
        return cornerFound ? i : UndercutPoints.Count - 1;
    }

    /// <summary>
    /// Once the undercut points and the dedendum points have been calculated,
    /// but before the number of points are reduced based on an error tolerance,
    /// any concave parts of the tooth profile may be too sharp cornered for
    /// a given cutter radius. This method redraws the undercut and dedendum
    /// profile so that it can accommodate the diameter of cutter we are
    /// intending to cut the gear with.
    /// </summary>
    /// <param name="cutterRadius">Radius of the end mill bit in mm</param>
    /// <returns>True if the points had to be adjusted, false if the
    /// curves were all sufficiently shallow that adjustment did
    /// not take place</returns>

    private bool AdjustPointsForCircularCutter(Coordinate cutterCentre)
    {
        if (UndercutPoints == null)
            return false;

        // First find the point at which an end-mill of the specified cutter
        // radius can no longer cut inside the concave profile of the undercut

        int i = IndexOfLastUndercutPointWithSufficientRadius();

        // Copy across the curve that we are able to follow before
        // deviating from it according to cutter radius

        if (UndercutPoints != null)
            UndercutPoints = new List<Coordinate>(UndercutPoints.Take(i + 1));
        var lastPt = UndercutPoints?.Last() ?? Coordinate.Empty;

        // Calculate the angle for the last point in the undercut curve

        double startAngle = Math.Atan2(lastPt.Y - cutterCentre.Y,
            lastPt.X - cutterCentre.X);

        // Find the point on the cutter circle that intersects a line from
        // its centre to the centre of the gear profile (origin 0,0)

        double cutterCentreRadius = Math.Sqrt(Geometry.SumOfSquares(cutterCentre.X, cutterCentre.Y));

        // Find the end angle for the cutter radius curve. This is the same as
        // the angle at the origin to the cutter centre, reflected by 180 degrees.

        double endAngle = Math.Atan2(cutterCentre.Y, cutterCentre.X) + Math.PI;

        // Add points around the cutter diameter from the last point
        // of adjustedUndercut, to the point at which it crosses yDedendum (y value).

        if (UndercutPoints != null)
            foreach (var c in Geometry.CirclePoints
                (startAngle, endAngle, Math.PI / 180, CutDiameter / 2, cutterCentre))
                UndercutPoints.Add(c);

        // Record the new dedendum diameter since the cutter has reduced it

        double cutterAdjustedDedendumCircleDiameter = 2 * cutterCentreRadius - CutDiameter;

        // Then add new dedendum circle points round to the y=0 axis, based on
        // the tangent to the cutter circle at yDedendum.

        DedendumPoints = new List<Coordinate>(Geometry.CirclePoints
            (-(BacklashAngle + endAngle - Math.PI), endAngle - Math.PI,
            Geometry.AngleStep, cutterAdjustedDedendumCircleDiameter / 2));

        // Undercut points and dedendum points were rewritten. Return
        // true to flag this fact.

        return true;
    }

    private IEnumerable<Coordinate> ComputeDedendumCirclePoints()
        => Geometry.CirclePoints
            (-(BacklashAngle + DedendumArcAngle / 2), DedendumArcAngle / 2,
            Geometry.AngleStep, DedendumCircleDiameter / 2);

    private IEnumerable<Coordinate> ComputeAddendumCirclePoints()
        => Geometry.CirclePoints
                (GapWidthAngleAtPitchCircle / 2 + ToothTipOffset,
                ToothAngle - GapWidthAngleAtPitchCircle / 2 - ToothTipOffset - BacklashAngle,
                Geometry.AngleStep, AddendumCircleDiameter / 2);

    private Coordinate underCutPoint = Coordinate.Empty;

    private void InitPointLists()
    {
        InvolutePoints = new List<Coordinate>(ComputeInvolutePoints());
        UndercutPoints = new List<Coordinate>(ComputeUndercutPoints());
        DedendumPoints = new List<Coordinate>(ComputeDedendumCirclePoints());

        underCutPoint = Geometry.ClosestPoint(InvolutePoints, UndercutPoints);
        int involuteIdx = Geometry.IndexOfLastPointWithGreaterXVal(InvolutePoints, underCutPoint.X);
        int undercutIdx = Geometry.IndexOfLastPointWithGreaterXVal(UndercutPoints, underCutPoint.X);

        // Find the trochoid forming angle parameter that maps to the point at
        // which the undercut trochoid crosses the gear's involute profile.

        double undercutStartAngle = UndercutAngleFromIndex(undercutIdx);

        // Find the index of the last coordinate in the undercut point list that can be
        // cut with the specified cutter diameter. Beyond this we have to broaden the
        // undercut arc to have the minimum radius of the cutter, and hence also have
        // a deeper dedendum.

        int undercutCorrectionIdx = IndexOfLastUndercutPointWithSufficientRadius();

        // Find the trochoid forming angle parameter that maps to the point
        // on the trochoid at which the radius becomes too tight for the
        // selected end mill radius. Beyond this point, we will use a
        // circular arc of radius equal to the end mill.

        double undercutEndAngle = UndercutAngleFromIndex(undercutCorrectionIdx);

        // Find the centre of the end mill at the start of the circular arc
        // used when applying undercut correction
        
        Coordinate cutterCentre = CutterCentreAtUnderCutIndex(undercutCorrectionIdx);

        // Find the start angle for the arc starting at the undercut correction point

        Coordinate lastPt = UndercutPoints[undercutCorrectionIdx];
        double correctionStartAngle = Math.Atan2(lastPt.Y - cutterCentre.Y,
            lastPt.X - cutterCentre.X);

        // Find the end angle for the cutter radius curve. This is the same as
        // the angle at the origin to the cutter centre, reflected by 180 degrees.

        double correctionEndAngle = Math.Atan2(cutterCentre.Y, cutterCentre.X) + Math.PI;

        // Record the new dedendum diameter since the cutter correction has reduced it

        cutterAdjustedDedendumCircleDiameter = 2 * cutterCentre.Magnitude - CutDiameter;

        if (CutDiameter > 0 && undercutCorrectionIdx < UndercutPoints.Count - 1)
            Information += "Undercut and dedendum adjusted for cutter diameter\r\n";
        if (ToothGapAtUndercut < CutDiameter)
            Information += $"Cutter dia. {CutDiameter} too wide for tooth gap of {ToothGapAtUndercut:N2}\r\n";

        // Now initialise the drawable objects, used to make the SVG
        // file much smaller using Bezier curves and arcs
        // TODO: check that moving InitDrawables above the point list adjustments below
        // doesn't mess up InitDrawable's assumptions about those point lists.

        InitDrawables(involuteIdx, undercutStartAngle, undercutEndAngle,
            cutterCentre, correctionStartAngle, correctionEndAngle);

        // Manage the coordinate lists if still rendering
        // the gear using lines between points.

        InvolutePoints.RemoveRange(involuteIdx + 1, InvolutePoints.Count - involuteIdx - 1);
        UndercutPoints.RemoveRange(0, undercutIdx + 1);
        AdjustPointsForCircularCutter(cutterCentre);
        AddendumPoints = new List<Coordinate>(ComputeAddendumCirclePoints());
        InvolutePoints = Geometry.LinearReduction(InvolutePoints, (float)MaxError);
        UndercutPoints = Geometry.LinearReduction(UndercutPoints, (float)MaxError);
        DedendumPoints = Geometry.LinearReduction(DedendumPoints, (float)MaxError);
        AddendumPoints = Geometry.LinearReduction(AddendumPoints, (float)MaxError);
    }

    /// <summary>
    /// Using the last two points in the undercut point sequence before the
    /// radius of curvature becomes too acute for the cutter with the end mill
    /// radius.
    /// </summary>
    /// <param name="undercutCorrectionIdx"></param>
    /// <returns>The coordinate of the centre of the cutter at the specified
    /// undercut coordinate</returns>
    
    private Coordinate CutterCentreAtUnderCutIndex(int undercutCorrectionIdx)
    {
        double m = UndercutPoints[undercutCorrectionIdx].Y 
            - UndercutPoints[undercutCorrectionIdx - 1].Y;
        m /= UndercutPoints[undercutCorrectionIdx].X 
            - UndercutPoints[undercutCorrectionIdx - 1].X;
        m = -1 / m; // Gradient of line perpendicular to last two coords
        double dx = CutDiameter /(2 * Geometry.RootSumOfSquares(1, m));
        double dy = m * dx;
        return new Coordinate(UndercutPoints[undercutCorrectionIdx].X + dx, 
            UndercutPoints[undercutCorrectionIdx].Y + dy);
    }

    IList<CubicSpline> InvoluteSplines;
    CircularArc AddendumCurve = null;
    CircularArc DedendumCurve = null;
    CircularArc UndercutAdjustment = null;
    IList<CubicSpline> UndercutSplines = null;

    /// <summary>
    /// Setup the drawing curves if not using all straight
    /// line segments
    /// </summary>
    /// <param name="involuteIdx">The index into the Involute
    /// point list of the last point with a greater X value
    /// than the intersection point with the undercut
    /// trochoid</param>
    
    private void InitDrawables(int involuteIdx, 
        double undercutStartAngle, double undercutEndAngle,
        Coordinate adjustedCentre, double adjustedStartAngle, 
        double adjustedEndAngle)
    {
        // Capture the addendum arc as an arc object instead
        // of a sequence of points

        AddendumCurve = new CircularArc
        {
            StartAngle = GapWidthAngleAtPitchCircle / 2 + ToothTipOffset,
            EndAngle = ToothAngle - GapWidthAngleAtPitchCircle / 2
                - ToothTipOffset - BacklashAngle,
            Anticlockwise = true,
            Centre = Coordinate.Empty,
            Radius = AddendumCircleDiameter / 2
        };

        // Capture the involute curve as a pair of cubic
        // splines. Note these are drawn from the addendum
        // towards the base circle to be consistent with
        // the previous points only version of the code.

        InvoluteSplines = new List<CubicSpline>(2);
        var bezPoints = InvoluteAsBezier(0, involuteIdx);
        InvoluteSplines.Add(new CubicSpline
        {
            Points = bezPoints.Skip(4).Reverse().ToArray()
        });
        InvoluteSplines.Add(new CubicSpline
        {
            Points = bezPoints.Take(4).Reverse().ToArray()
        });

        // Capture the undercut trochoid as a pair of cubic
        // splines. These are drawn from the inner end of
        // the involute curve towards the dedendum, but halt
        // at the point the curvature is too sharp for the
        // end-mill cutter diameter.

        UndercutSplines = new List<CubicSpline>(2);
        bezPoints = UndercutAsBezier(undercutStartAngle, undercutEndAngle);
        UndercutSplines.Add(new CubicSpline
        {
            Points = bezPoints.Skip(4).Reverse().ToArray()
        });
        UndercutSplines.Add(new CubicSpline
        {
            Points = bezPoints.Take(4).Reverse().ToArray()
        });

        // Capture the undercut adjustment curve, assuming
        // there is one. This is determined by the inequality
        // in the start and end angles for the adjustment.

        if(adjustedEndAngle != adjustedStartAngle)
        {
            UndercutAdjustment = new CircularArc
            {
                StartAngle = adjustedStartAngle,
                EndAngle = adjustedEndAngle,
                Anticlockwise = true,
                Centre = adjustedCentre,
                Radius = CutDiameter / 2
            };
        }

        // When preparing the dedendum curve, assume that the
        // adjusted end angle was always set to the end of the
        // adjusted curve, or to the end of the trochoid, and
        // that the centre of the adjustment is always set
        // one cutter radius beyond that point radially.

        double dedendumHalfAngle = adjustedEndAngle - Math.PI;

        // Capture the dedendum arc as an arc object instead
        // of a sequence of points on a circle. Note we are
        // using the actual points list as it may have been
        // adjusted for a high diameter end mill.

        DedendumCurve = new CircularArc
        {
            StartAngle = -dedendumHalfAngle - BacklashAngle,
            EndAngle = dedendumHalfAngle,
            Anticlockwise = true,
            Radius = InnerDiameter/ 2
        };
    }

    /// <summary>
    /// Return the set of eight points that represent the control points of
    /// two bezier curves that approximate the involute gear surface. Using
    /// the SVG path rendering, this would be rendered inner to outer as:
    /// .MoveTo(coord[0]);
    /// .Cubic(coord[1], coord[2], coord[3]);
    /// .MoveTo(coord[4]); - leaving this out will remove a slight step in the curve
    /// .Cubic(coord[5], coord[6], coord[7]);
    /// For rendering outer to inner, the coordinate indices would be
    /// reversed to 7...0.
    /// </summary>
    /// <param name="lowerIndex">The index into the involute point list
    /// of the earliest point to include in the curve</param>
    /// <param name="upperIndex">The index into the involute point
    /// list of the last point on the involute before the undercut</param>
    /// <returns>The Bezier control points for the involute, in the order
    /// inner to outer end radially (opposite to InvolutePoints list)</returns>
    
    public List<Coordinate> InvoluteAsBezier(int lowerIndex, int upperIndex)
    {
        // Angle away from centre of gap between teeth
        // at which the involute touches the base circle.
        // This is because we calculate the gear to have a tooth
        // gap aligned with the positive X axis.

        double involuteBaseAngle = GapWidthAngleAtPitchCircle / 2 - ToothBaseOffset;

        // First grab the radii at which the involute begins and ends
        // from just beyond the point at which the undercut trochoid
        // intersects with it out to the addendum radius

        double startRadius = InvolutePoints[upperIndex].Magnitude;
        double endRadius = InvolutePoints[lowerIndex].Magnitude;

        // The two functions that compute the X,Y coordinate on the
        // involute curve from the angle between the X axis and the
        // line to the tangent point for the line unwinding from the
        // circle to form the involute. These functions assume the
        // involute meets the base circle on the X axis, so the whole
        // curve will need to be rotated to the correct point to form
        // the tooth surface.
        
        Func<double, Coordinate> involuteFunctions =
            angle => new Coordinate(
                BaseCircleDiameter / 2.0 
                    * (Math.Cos(angle) + angle * Math.Sin(angle)),
                BaseCircleDiameter / 2.0 
                    * (Math.Sin(angle) - angle * Math.Cos(angle)));

        // Find the angles between the X axis and the tangent of the line
        // that unwinds from the circle to form the involute at its end

        double endAngle = 2 * Geometry.RootDiffOfSquares
            (endRadius, BaseCircleDiameter / 2) / BaseCircleDiameter;
        double startAngle = 2 * Geometry.RootDiffOfSquares
            (startRadius, BaseCircleDiameter / 2) / BaseCircleDiameter;

        // As there is an abrupt discontinuity in the involute curve at
        // the angle of zero, we move a small way away from it when creating
        // the Bezier spline

        if (startAngle == 0)
            startAngle += 0.01 * (endAngle - startAngle);

        // We represent the involute using two Bezier curves end to end, to
        // minimise the errors caused by the Tchebyshev approximation. The
        // point at which we split the curves is 3/8ths of the way along
        // the range of angles we plot the curve over.

        double midAngle = startAngle + 0.375 * (endAngle - startAngle);

        // Now use the Spline class to do the donkeywork for us

        Spline inner = new Spline(3, involuteFunctions, startAngle, midAngle);
        Spline outer = new Spline(3, involuteFunctions, midAngle, endAngle);
        List<Coordinate> points = new();

        // The eight control points for the two Bezier curves are returned
        // consecutively in an eight element list. Note that the points
        // are all rotated to the correct angle for a gear being constructed
        // with the midpoint of the dedendum aligned with the X axis.

        points.AddRange(inner.ControlPoints.Rotated(involuteBaseAngle));
        points.AddRange(outer.ControlPoints.Rotated(involuteBaseAngle));
        return points;
    }

    public List<Coordinate> UndercutAsBezier(double startAngle, double endAngle)
    {
        // The two functions that compute the X,Y coordinate on the
        // undercut trochoid from the angle between the X axis and the
        // line to the tangent point for the line unwinding from the
        // circle to form the trochoid's parent involute. The trochoid
        // occurs because the tooth corner is at an offset from the
        // parent involute unwinding from the pitch circle.

        Func<double, Coordinate> undercutFunctions =
            angle => Geometry.InvolutePlusOffset(
                PitchCircleDiameter / 2,
                -Module * (1 - ProfileShift),
                Module * (Math.PI / 4 - Math.Tan(PressureAngle)),
                angle, 0);

        // As there is an abrupt discontinuity in the involute curve at
        // the angle of zero, we move a small way away from it when creating
        // the Bezier spline

        if (startAngle == 0)
            startAngle += 0.01 * (endAngle - startAngle);

        // We represent the involute using two Bezier curves end to end, to
        // minimise the errors caused by the Tchebyshev approximation. The
        // point at which we split the curves is 3/8ths of the way along
        // the range of angles we plot the curve over.

        double midAngle = startAngle + 0.375 * (endAngle - startAngle);

        // Now use the Spline class to do the donkeywork for us

        Spline inner = new Spline(3, undercutFunctions, startAngle, midAngle);
        Spline outer = new Spline(3, undercutFunctions, midAngle, endAngle);
        List<Coordinate> points = new();

        // The eight control points for the two Bezier curves are returned
        // consecutively in an eight element list. Note that the points
        // are already rotated to the correct angle for a gear with
        // the midpoint of the dedendum aligned with the X axis.

        points.AddRange(inner.ControlPoints);
        points.AddRange(outer.ControlPoints);
        return points;
    }

    /// <summary>
    /// Generate the complete outline of the
    /// whole gear in a single list of points.
    /// </summary>
    /// <returns>The points that make up the outline of
    /// the gear. The last point should be joined back
    /// onto the first point to close the outline.</returns>

    private IEnumerable<Coordinate> GenerateCompleteGearPath() => Enumerable
            .Range(0, ToothCount)
            .Select(i => GeneratePointsForOnePitch(i))
            .SelectMany(ep => ep)
            .SelectMany(p => p);

    private IEnumerable<IEnumerable<Coordinate>> GeneratePointsForOnePitch(int i)
    {
        yield return ClockwiseInvolute(i);
        yield return ClockwiseUndercut(i);
        yield return Dedendum(i);
        yield return AnticlockwiseUndercut(i);
        yield return AnticlockwiseInvolute(i);
        yield return Addendum(i);
    }

    /// <summary>
    /// Given we have previously generated all the various
    /// bits of the gear profile, now generate the full wheel
    /// </summary>
    /// <returns>The path for the whole gear circumference</returns>
    
    public DrawablePath GenerateGearCurve()
    {
        if (linesOnly)
        {
            return new DrawablePath
            {
                Curves = new List<IDrawable>
                {
                    new PolyLine
                    {
                        Vertices = GenerateCompleteGearPath().ToList()
                    }
                },
                Closed = true
            };
        }
        else
        {
            return new DrawablePath
            {
                Curves = new List<IDrawable>(Enumerable
                    .Range(0, ToothCount)
                    .Select(i => GeneratePathElementsForOnePitch(i))
                    .SelectMany(ep => ep)),
                Closed = true
            };
        }
    }

    public IEnumerable<IDrawable> GeneratePathElementsForOnePitch(int i)
    {
        // The angles between the middles of adjacent
        // teeth in radians is 2*PI / ToothCount

        double gapCentreAngle = (i % ToothCount) * ToothAngle - BacklashAngle;
        List<IDrawable> elements = new List<IDrawable>();

        // Add the involute inbound from the addendum

        foreach(var e in InvoluteSplines)
            elements.Add(e.ReflectY()
                .RotatedBy(gapCentreAngle, Coordinate.Empty));

        // Add the undercut trochoid 

        foreach (var e in UndercutSplines.Reverse())
            elements.Add(e.Reversed()
                .ReflectY()
                .RotatedBy(gapCentreAngle, Coordinate.Empty));

        // Add the adjustment arc

        elements.Add(UndercutAdjustment.ReflectY()
            .RotatedBy(gapCentreAngle, Coordinate.Empty));

        // Add the dedendum arc

        elements.Add(DedendumCurve
            .RotatedBy(i % ToothCount * ToothAngle, Coordinate.Empty));

        // Add the adjustment arc the other side of the dedendum

        elements.Add(UndercutAdjustment.Reversed()
                .RotatedBy(i % ToothCount * ToothAngle, Coordinate.Empty));

        // Add the undercut on the other side of the dedendum

        foreach (var e in UndercutSplines)
            elements.Add(e
                .RotatedBy(i % ToothCount * ToothAngle, Coordinate.Empty));

        // Add the involute curves on the other side of the dedendum
        
        foreach (var e in InvoluteSplines.Reverse())
            elements.Add(e.Reversed()
                .RotatedBy(i % ToothCount * ToothAngle, Coordinate.Empty));

        // Last, add the addendum arc

        elements.Add(AddendumCurve
            .RotatedBy(i % ToothCount * ToothAngle, Coordinate.Empty));

        return elements;
    }

    /// <summary>
    /// Reflect a sequence of points to the opposite side of the X axis
    /// </summary>
    /// <param name="points">The points to be reflected</param>
    /// <returns>The reflected points</returns>

    public static IEnumerable<Coordinate> ReflectY(IEnumerable<Coordinate> points)
        => points.Select(p => p.Conjugate);

    /// <summary>
    /// The angle around the gear subtended by the Backlash
    /// property value. Backlash is measured as a fraction
    /// of the Module, but we don't want to have units
    /// scaled up by PI around the gear but not radially.
    /// Hence we define backlash as the fraction of the
    /// module length around the pitch circle.
    /// </summary>

    private double BacklashAngle
        => 2 * Backlash / ToothCount;

    /// <summary>
    /// Given a list of points, rotate them about the origin
    /// by a whole number of tooth angles
    /// </summary>
    /// <param name="points">The points to rotate about the origin</param>
    /// <param name="gap">The gap number for the tooth, in the
    /// range 0 to ToothCount - 1</param>
    /// <returns>The rotated set of points</returns>

    private IEnumerable<Coordinate> RotateByTeeth(IEnumerable<Coordinate>? points, int gap)
        => points?.Rotated((gap % ToothCount) * ToothAngle)
            ?? Enumerable.Empty<Coordinate>();

    /// <summary>
    /// Given the selected tooth number, compute the list of points that
    /// make up the side of the tooth anticlockwise from the gap selected.
    /// On the positive X axis is the centre of gap zero between two teeth.
    /// Above it is the anticlockwise involute.
    /// </summary>
    /// <param name="gap">The numbered gap between teeth. Gap zero lies
    /// along the positive X axis, with gaps numbered anticlockwise
    /// from there.</param>
    /// <returns>The list of points making up the involute from the
    /// base circle up to the edge of the addendum</returns>

    private IEnumerable<Coordinate> AnticlockwiseInvolute(int gap)
        => RotateByTeeth(InvolutePoints, gap).Reverse();

    /// <summary>
    /// Given the selected tooth number, compute the list of points that
    /// make up the side of the tooth clockwise from the gap selected.
    /// On the positive X axis is the centre of gap zero between two teeth.
    /// Below it is the clockwise involute.
    /// </summary>
    /// <param name="gap">The numbered gap between teeth. Gap zero lies
    /// along the positive X axis, with gaps numbered anticlockwise
    /// from there.</param>
    /// <returns>The list of points making up the involute from the
    /// base circle up to the edge of the addendum</returns>

    private IEnumerable<Coordinate> ClockwiseInvolute(int gap)
        => ReflectAndAddBacklash(InvolutePoints, gap);

    private IEnumerable<Coordinate> Dedendum(int gap)
        => RotateByTeeth(DedendumPoints, gap);

    private IEnumerable<Coordinate> Addendum(int gap)
        => RotateByTeeth(AddendumPoints, gap);

    private IEnumerable<Coordinate> ReflectAndAddBacklash(IEnumerable<Coordinate>? points, int gap)
    {
        if (points == null)
            return Enumerable.Empty<Coordinate>();

        // The angles between the middles of adjacent
        // teeth in radians is 2*PI / ToothCount

        double gapCentreAngle = (gap % ToothCount) * ToothAngle - BacklashAngle;
        return ReflectY(points).Rotated(gapCentreAngle);
    }

    /// <summary>
    /// Given the gap number around the gear, calculate the points on the
    /// curve for the undercut from where it is tangential to the dedendum
    /// circle round to where it crosses the pitch circle. This is sufficient
    /// for all gears containing five or more teeth. At four teeth, the
    /// undercut exceeds the pitch circle.This function calculates
    /// the under cut anticlockwise from the gap selected.
    /// </summary>
    /// <param name="gap">The numbered gap between teeth. Gap zero lies
    /// along the positive X axis, with gaps numbered anticlockwise
    /// from there.</param>
    /// <returns>The list of points making up the trochoid from the
    /// dedendum circle up to the pitch circle</returns>

    private IEnumerable<Coordinate> AnticlockwiseUndercut(int gap)
    {
        double gapCentreAngle = (gap % ToothCount) * ToothAngle;
        return UndercutPoints
            .Rotated(gapCentreAngle)
            .Reverse();
    }

    /// <summary>
    /// Given the gap number around the gear, calculate the points on the
    /// curve for the undercut from where it is tangential to the dedendum
    /// circle round to where it crosses the pitch circle. This is sufficient
    /// for all gears containing five or more teeth. At four teeth, the
    /// undercut exceeds the pitch circle. This function calculates
    /// the under cut clockwise from the gap selected.
    /// </summary>
    /// <param name="gap">The numbered gap between teeth. Gap zero lies
    /// along the positive X axis, with gaps numbered anticlockwise
    /// from there.</param>
    /// <returns>The list of points making up the trochoid from the
    /// dedendum circle up to the pitch circle</returns>

    private IEnumerable<Coordinate> ClockwiseUndercut(int gap)
        => ReflectAndAddBacklash(UndercutPoints, gap);

    /// <summary>
    /// The angle between the two points on the dedendum circle at which
    /// the two corners of the mating tooth's addendum touch the
    /// dedendum circle. Used for determining where the undercut curve
    /// starts on the dedendum circle.
    /// </summary>

    private double DedendumArcAngle
        => (Pitch - 4 * Module * Math.Tan(PressureAngle)) / PitchCircleDiameter;

    /// <summary>
    /// The angle from tooth centreline to edge of tooth crossing pitch
    /// circle when undercutting on trailing edge of tooth on rotation.
    /// Also accommodates profile shifting of the tooth.
    /// </summary>

    private double UndercutAngleAtPitchCircle
    {
        get
        {
            double shiftedModule = Module * (1 - ProfileShift);
            double k = Math.Sqrt(shiftedModule * PitchCircleDiameter - Geometry.Square(shiftedModule));
            double j = k - Module * (Math.PI / 4 - Math.Tan(PressureAngle));
            return 2 * j / PitchCircleDiameter;
        }
    }

    /// <summary>
    /// Given an angle, find the count of the number of whole
    /// steps in angle of size AngleStep fit into that angle.
    /// Round down any partial step left over.
    /// </summary>
    /// <param name="angle">The angle to be indexed</param>
    /// <returns>The number of steps in this angle</returns>
    
    private static int AngleIndexFloor(double angle)
        => (int)(angle / Geometry.AngleStep);

    /// <summary>
    /// Given an overall gear ratio (numerator/denominator) and the minimum
    /// and maximum number of teeth on each gear to search between, find two
    /// gear and pinion pairs that would produce the desired ratio back onto
    /// the original spindle. Examples of the use would be minute hand to
    /// hour hand reduction where the minute and hour hand are coaxial.
    /// </summary>
    /// <param name="numerator">Numerator part of the desired gear ratio</param>
    /// <param name="denominator">Denominator part of the desired gear ratio</param>
    /// <param name="minTeeth">Minimum tooth count tolerated on the pinions</param>
    /// <param name="maxTeeth">Maximum tooth count tolerated on the gears</param>
    /// <returns>A string with all workable gear and pinion tooth counts,
    /// together with the overall separation between spindles measured in
    /// multiples of the module</returns>

    public static string MatchedPairs(int numerator, int denominator, int minTeeth, int maxTeeth)
    {
        string result = string.Empty;
        for (int b = minTeeth; b <= maxTeeth; b++)
            for (int c = minTeeth; c <= maxTeeth; c++)
                for (int d = minTeeth; d <= maxTeeth; d++)
                    if (denominator * ((c + d - b) * c) == numerator * b * d)
                        result += $"{c + d - b}/{b} * {c}/{d}, {c + d}\r\n";
        return result;
    }

    /// <summary>
    /// Calculate the contact ratio for two gears. The gears must be
    /// compatible from a meshing point of view (same module, same
    /// pressure angle). The contact ratio is the average number of teeth
    /// in contact with each other on the pressure-bearing faces as
    /// the gears are rotating. Ideally this should be > 1.1, but the
    /// absolute minimum is 1 for the gears to not 'click' as they turn.
    /// Note that this is the ideal figure, valid for no backlash, no
    /// profile offset, and no undercut. It is the theoretical maximum
    /// value that is never achieved!
    /// </summary>
    /// <param name="g1">The first gear being meshed</param>
    /// <param name="g2">The second gear being meshed</param>
    /// <returns>The contact ratio</returns>

    public static double IdealContactRatio(InvoluteGearParameters g1, InvoluteGearParameters g2)
    {
        if (g1 == null || !g1.CanMeshWith(g2))
            throw new ArgumentException("Gears have differing modules or pressure angles");

        double gear1 = 0.5 * Geometry.RootDiffOfSquares
            (g1.PitchCircleDiameter + 2 * g1.Module, g1.BaseCircleDiameter);
        double gear2 = 0.5 * Geometry.RootDiffOfSquares
            (g2.PitchCircleDiameter + 2 * g2.Module, g2.BaseCircleDiameter);
        return (gear1 + gear2 - Math.Sin(g1.PressureAngle)
            * (g1.PitchCircleDiameter + g2.PitchCircleDiameter) / 2)
            / g1.BaseCirclePitch;
    }
}
