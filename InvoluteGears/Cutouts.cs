using System;
using System.Collections.Generic;
using System.Linq;
using TwoDimensionLib;

namespace InvoluteGears;

/// <summary>
/// Computes the cutouts of gear faces to reduce gear inertia
/// for larger gears. Computes the central cutouts for
/// bearings or spindles.
/// </summary>

public class Cutouts
{
    /// <summary>
    /// The gear this cutout is being applied to
    /// </summary>

    public IGearProfile Gear { get; private set; }

    /// <summary>
    /// The diameter of the hole right through the centre of the gear
    /// </summary>

    public double SpindleDiameter { get; private set; }

    /// <summary>
    /// The diameter of an optional inlaid bearing, that is
    /// inserted from one side of the gear. Set zero to
    /// not use this.
    /// </summary>

    public double InlayDiameter { get; private set; }

    /// <summary>
    /// The distance across the flats of the hexagonal
    /// key shape drawn on the cutout. This hex key is
    /// used to align adjacent gears where they are
    /// keyed together as a wheel-pinion pair.
    /// </summary>

    public double KeyWidth { get; private set; }

    /// <summary>
    /// Used for warning or information messages when methods invoked
    /// </summary>

    public string Information { get; private set; }

    /// <summary>
    /// Error messages generated by the gear generators. If an
    /// empty string, the gear generation has succeeded and the
    /// other fields will contain data. If non-empty the other
    /// fields may be empty or null.
    /// </summary>

    public string Errors { get; private set; }

    /// <summary>
    /// Calculate the number of spokes between the hub
    /// and the perimeter of the gear. Based on the number
    /// of teeth in the gear.
    /// </summary>
    /// <returns>The number of spokes to cut out</returns>

    private int SpokeCount()
    {
        int spokes = 1 + (Gear.ToothCount - 1) / 8;
        return spokes >= 3 ? spokes : 0;
    }

    /// <summary>
    /// Constructor
    /// </summary>
    /// <param name="gear">The gear we wish to calculate cutouts for</param>
    /// <param name="spindle">The diameter of the central hole in the gear</param>
    /// <param name="inlay">The diameter of the bearing inlay</param>
    /// <param name="keyWidth">The distance across flats of the hex key for attaching
    /// gears to each other truly</param>

    public Cutouts(IGearProfile gear, double spindle, double inlay, double keyWidth)
    {
        Errors = string.Empty;
        if (spindle < 0 || inlay < 0 || keyWidth < 0)
            throw new ArgumentException("Dimensions cannot be negative");
        Gear = gear ?? throw new ArgumentException("No gear specified for cut out");
        SpindleDiameter = spindle;
        InlayDiameter = inlay;
        KeyWidth = keyWidth;

        // First curve is the gear teeth profile

        Curves = gear.GenerateGearCurves(); // TODO: "black", "transparent"

        // Next add any cutouts in the gear

        int spokes = SpokeCount();
        foreach (var dp in CalculateCutoutCurves(spokes))
            AddCurve(dp, "black", "transparent");

        // Now add the three spindle-centred items

        if (SpindleDiameter > 0)
        {
            AddCurve(CalculateSpindleCurve(), "black", "transparent");
            Information += $"Spindle dia. = {SpindleDiameter}mm, ";
        }
        else
            Information += "No spindle, ";

        if (InlayDiameter > 0)
        {
            AddCurve(CalculateInlayCurve(), "black", "transparent");
            Information += $"inlay dia. = {InlayDiameter}mm, ";
        }
        else
            Information += "no inlay, ";
        if (KeyWidth > 0)
        {
            AddCurve(CalculateHexKeyCurve(), "black", "transparent");
            Information += $"hex key width = {KeyWidth}mm\r\n";
        }
        else
            Information += "no hex key\r\n";
    }

    /// <summary>
    /// Add an extra cutout profile to the list of curves to be
    /// drawn by this cutout. Capture the proposed fill and
    /// stroke colours at the same time.
    /// </summary>
    /// <param name="d">The drawable to be added</param>
    /// <param name="stroke">The stroke colour</param>
    /// <param name="fill">The fill colour</param>

    public void AddCurve(DrawablePath d, string stroke, string fill)
    {
        Curves.Paths.Add(d);
        FillColours.Add(fill);
        StrokeColours.Add(stroke);
    }

    /// <summary>
    /// Insert an extra cutout profile at the front of the
    /// list of curves to be drawn by this cutout. Capture 
    /// the proposed fill and stroke colours at the same time.
    /// WARNING: inserting at the front of the list is not
    /// very efficient. Use AddCurve when there is a choice.
    /// </summary>
    /// <param name="d"></param>
    /// <param name="stroke"></param>
    /// <param name="fill"></param>

    public void InsertCurve(DrawablePath d, string stroke, string fill)
    {
        Curves.Paths.Insert(0, d);
        FillColours.Insert(0, fill);
        StrokeColours.Insert(0, stroke);
    }

    /// <summary>
    /// The cutout shapes to be added to the gear point sets
    /// </summary>

    public DrawableSet Curves { get; private set; }
    public IList<string> FillColours { get; private set; } = new List<string>();
    public IList<string> StrokeColours { get; private set; } = new List<string>();

    /// <summary>
    /// Calculate the drawable that forms the spindle circle
    /// </summary>
    /// <returns>The drawable that makes up the hole
    /// in the middle of the gear</returns>

    private DrawablePath CalculateSpindleCurve()
        => CircularArc.Circle(SpindleDiameter / 2, Coordinate.Empty);

    /// <summary>
    /// Calculate the drawable that forms the inlaid circle
    /// </summary>
    /// <returns>A circular arc for the inlay</returns>

    private DrawablePath CalculateInlayCurve()
        => CircularArc.Circle(InlayDiameter / 2, Coordinate.Empty);

    private IList<DrawablePath> CalculateCutoutCurves(int spokes)
    {
        IList<DrawablePath> cutoutCurves = new List<DrawablePath>();
        if (spokes < 3)
            return cutoutCurves;

        // Set some design constants

        double cornerRadius = Gear.Module;
        double spokeThickness = 2.0 * Gear.Module;
        double minHubDiameter = 8 * Gear.Module;

        // Calculate the minimum hub diameter for a given number of
        // spokes, a specified spoke thickness and corner radius.

        double hubDiameter = (spokeThickness + 2 * cornerRadius)
            / Math.Sin(Math.PI / spokes) - cornerRadius;
        if (hubDiameter < minHubDiameter)
            hubDiameter = minHubDiameter;

        // Calculate the corner at the outer end of one side of a spoke.
        // For this reference spoke we assume the spoke runs along the
        // positive X axis. We shall rotate it for other spokes.

        double rimDiameter = Gear.InnerDiameter - 2.0 * spokeThickness;
        if (rimDiameter < hubDiameter + 4 * cornerRadius)
            return cutoutCurves;

        double cornerCentreY = spokeThickness / 2 + cornerRadius;
        double rimCornerCentreX = Math.Sqrt
            (Geometry.DiffOfSquares(rimDiameter / 2 - cornerRadius, cornerCentreY));
        Coordinate rimCornerCentre = new(rimCornerCentreX, cornerCentreY);
        double angleAtRim = Math.Atan2(cornerCentreY, rimCornerCentreX);
        IDrawable outerCornerCurve = new CircularArc
        {
            StartAngle = -Math.PI / 2,
            EndAngle = angleAtRim,
            Radius = cornerRadius,
            Centre = rimCornerCentre,
            Anticlockwise = true
        };

        // Calculate the corner at the inner end of a spoke.

        double hubCornerCentreX = Math.Sqrt
            (Geometry.DiffOfSquares(hubDiameter / 2 + cornerRadius, cornerCentreY));
        Coordinate hubCornerCentre = new(hubCornerCentreX, cornerCentreY);
        double angleAtHub = Math.Atan2(cornerCentreY, hubCornerCentreX);

        IDrawable innerCornerCurve = new CircularArc
        {
            StartAngle = Math.PI + angleAtHub,
            EndAngle = 1.5 * Math.PI,
            Radius = cornerRadius,
            Centre = hubCornerCentre,
            Anticlockwise = true
        };

        IDrawable outerRimCurve = new CircularArc
        {
            StartAngle = angleAtRim,
            EndAngle = 2 * Math.PI / spokes - angleAtRim,
            Radius = rimDiameter / 2,
            Centre = Coordinate.Empty,
            Anticlockwise = true
        };

        IDrawable hubCurve = new CircularArc
        {
            StartAngle = angleAtHub,
            EndAngle = 2 * Math.PI / spokes - angleAtHub,
            Radius = hubDiameter / 2,
            Centre = Coordinate.Empty,
            Anticlockwise = true
        };

        // Construct the first cutout curve from its
        // various bends and straight lines

        IList<IDrawable> cutoutCurve = new List<IDrawable>
        {
            innerCornerCurve,
            new Line
                (innerCornerCurve.End, outerCornerCurve.Start),
            outerCornerCurve,
            outerRimCurve,
            outerCornerCurve
                .ReflectY()
                .RotatedBy(2 * Math.PI / spokes, Coordinate.Empty)
                .Reversed()
        };
        IDrawable otherInnerCornerCurve = innerCornerCurve
            .ReflectY()
            .RotatedBy(2 * Math.PI / spokes, Coordinate.Empty)
            .Reversed();
        cutoutCurve.Add(new Line
            (cutoutCurve.Last().End, otherInnerCornerCurve.Start));
        cutoutCurve.Add(otherInnerCornerCurve);
        cutoutCurve.Add(hubCurve.Reversed());

        // Now add the cutout curve to the list of curves

        cutoutCurves.Add(new DrawablePath
        {
            Curves = cutoutCurve,
            Closed = true
        });

        // Repeat for each of the other spokes in the wheel

        for (int i = 1; i < spokes; i++)
        {
            IList<IDrawable> cutout = new List<IDrawable>();
            cutout.AddRange(cutoutCurve.Select(c => c.RotatedBy
                    (2 * Math.PI * i / spokes, Coordinate.Empty)));
            cutoutCurves.Add(new DrawablePath
            {
                Curves = cutout,
                Closed = true
            });
        }
        return cutoutCurves;
    }

    /// <summary>
    /// Create a hexagonal key shape
    /// around the inlay so that
    /// two gears can be married on
    /// the same centres correctly
    /// </summary>
    /// <returns>The list of drawables 
    /// corresponding to the hex key</returns>

    private DrawablePath CalculateHexKeyCurve()
    {
        // Generate the points for one sixth of the key
        double ctrToFace = KeyWidth / 2;
        Coordinate cornerCtr = new(
            ctrToFace - Gear.CutDiameter / 2,
            (ctrToFace - Gear.CutDiameter / 2) / Math.Sqrt(3.0));
        IList<IDrawable> keyCurves = new List<IDrawable>()
        {
            new Line(new Coordinate(ctrToFace, 0),
                new Coordinate(ctrToFace, cornerCtr.Y)),
            new CircularArc
            {
                StartAngle = 0,
                EndAngle = Math.PI / 3,
                Radius = Gear.CutDiameter / 2,
                Centre = cornerCtr,
                Anticlockwise = true
            }
        };
        for (int i = 1; i <= 5; i++)
        {
            keyCurves.Add(keyCurves[0]
                .RotatedBy(i * Math.PI / 3.0, Coordinate.Empty));
            keyCurves.Add(keyCurves[1]
                .RotatedBy(i * Math.PI / 3.0, Coordinate.Empty));
        }
        return new DrawablePath
        {
            Curves = keyCurves,
            Closed = true
        };
    }
}

