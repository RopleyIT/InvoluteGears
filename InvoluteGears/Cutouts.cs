using System;
using System.Collections.Generic;
using System.Linq;
using TwoDimensionLib;

namespace InvoluteGears;

/// <summary>
/// Computes the cutouts of gear faces to reduce gear inertia
/// for larger gears. Computes the central cutouts for
/// bearings or spindles.
/// </summary>

public class Cutouts
{
    /// <summary>
    /// The gear this cutout is being applied to
    /// </summary>

    public IGearProfile Gear { get; private set; }

    /// <summary>
    /// The diameter of the hole right through the centre of the gear
    /// </summary>

    public double SpindleDiameter { get; private set; }

    /// <summary>
    /// The diameter of an optional inlaid bearing, that is
    /// inserted from one side of the gear. Set zero to
    /// not use this.
    /// </summary>

    public double InlayDiameter { get; private set; }

    /// <summary>
    /// The distance across the flats of the hexagonal
    /// key shape drawn on the cutout. This hex key is
    /// used to align adjacent gears where they are
    /// keyed together as a wheel-pinion pair.
    /// </summary>

    public double KeyWidth { get; private set; }

    /// <summary>
    /// Used for warning or information messages when methods invoked
    /// </summary>

    public string Information { get; private set; }

    /// <summary>
    /// Error messages generated by the gear generators. If an
    /// empty string, the gear generation has succeeded and the
    /// other fields will contain data. If non-empty the other
    /// fields may be empty or null.
    /// </summary>

    public string Errors { get; private set; }

    /// <summary>
    /// Cutout to leave just the spokes, reducing the
    /// moment of inertia of the gear
    /// </summary>
    
    public ICutouts CutoutCurveGenerator { get; set; }

    /// <summary>
    /// Cutout to provide keying when a gear and a
    /// sprocket or other type of lever need to be
    /// locked to each other
    /// </summary>
    
    public ICutouts KeyGenerator { get; set; }

    /// <summary>
    /// Constructor
    /// </summary>
    /// <param name="gear">The gear we wish to calculate cutouts for</param>
    /// <param name="spindle">The diameter of the central hole in the gear</param>
    /// <param name="inlay">The diameter of the bearing inlay</param>
    /// <param name="keyWidth">The distance across flats of the hex key for attaching
    /// gears to each other truly</param>

    public Cutouts(IGearProfile gear, double spindle, double inlay, double keyWidth)
    {
        Errors = string.Empty;
        if (spindle < 0 || inlay < 0 || keyWidth < 0)
        {
            Errors += "Dimensions cannot be negative\r\n";
            spindle = 0;
            inlay = 0;
            keyWidth = 0;
        }
        if (inlay != 0 && spindle > inlay)
        {
            Errors += "Spindle diameter bigger than bearing inlay\r\n";
        }
        if (keyWidth != 0 && (spindle > keyWidth || inlay > keyWidth))
        {
            Errors += "Keywidth should not be less than spindle or inlay diameters\r\n";
        }

        Gear = gear ?? throw new ArgumentException("No gear specified for cut out");
        SpindleDiameter = spindle;
        InlayDiameter = inlay;
        KeyWidth = keyWidth;

        // Inject the default cutout generators for
        // the spokes and for the keying shape(s)

        CutoutCurveGenerator = new CutoutCurves();
        KeyGenerator = new HexCutoutKey(keyWidth);

        // First curve is the gear teeth profile

        Curves = gear.GenerateGearCurves();
        for(int i =0; i < Curves.Paths.Count; i++)
        {
            FillColours.Add("transparent");
            StrokeColours.Add("black");
        }

        // Next add any cutouts in the gear to machine the spokes and rim

        AddCurves(CutoutCurveGenerator.CalculateCutouts(Gear), "black", "transparent");

        // Now add the three spindle-centred items

        if (SpindleDiameter > 0)
        {
            AddCurve(CalculateSpindleCurve(), "black", "transparent");
            Information += $"Spindle dia. = {SpindleDiameter}mm, ";
        }
        else
            Information += "No spindle, ";

        if (InlayDiameter > 0)
        {
            AddCurve(CalculateInlayCurve(), "black", "transparent");
            Information += $"inlay dia. = {InlayDiameter}mm, ";
        }
        else
            Information += "no inlay, ";
        if (KeyWidth > 0)
        {
            AddCurves(KeyGenerator.CalculateCutouts(Gear), "black", "transparent");
            Information += $"hex key width = {KeyWidth}mm\r\n";
        }
        else
            Information += "no hex key\r\n";
    }

    /// <summary>
    /// Add an extra cutout profile to the list of curves to be
    /// drawn by this cutout. Capture the proposed fill and
    /// stroke colours at the same time.
    /// </summary>
    /// <param name="d">The drawable to be added</param>
    /// <param name="stroke">The stroke colour</param>
    /// <param name="fill">The fill colour</param>

    public void AddCurve(DrawablePath d, string stroke, string fill)
    {
        Curves.Paths.Add(d);
        FillColours.Add(fill);
        StrokeColours.Add(stroke);
    }

    /// <summary>
    /// Add a sequence of curves to the curve set using the same
    /// fill and stroke colours
    /// </summary>
    /// <param name="curves">The list of paths to add</param>
    /// <param name="stroke">The colour for the pen strokes</param>
    /// <param name="fill">The fill colour for a closed shape</param>
    
    public void AddCurves(IEnumerable<DrawablePath> curves, string stroke, string fill)
    {
        foreach(var curve in curves)
            AddCurve(curve, stroke, fill);
    }

    /// <summary>
    /// Insert an extra cutout profile at the front of the
    /// list of curves to be drawn by this cutout. Capture 
    /// the proposed fill and stroke colours at the same time.
    /// WARNING: inserting at the front of the list is not
    /// very efficient. Use AddCurve when there is a choice.
    /// </summary>
    /// <param name="d"></param>
    /// <param name="stroke"></param>
    /// <param name="fill"></param>

    public void InsertCurve(DrawablePath d, string stroke, string fill)
    {
        Curves.Paths.Insert(0, d);
        FillColours.Insert(0, fill);
        StrokeColours.Insert(0, stroke);
    }

    /// <summary>
    /// The cutout shapes to be added to the gear point sets
    /// </summary>

    public DrawableSet Curves { get; private set; }
    public IList<string> FillColours { get; private set; } = new List<string>();
    public IList<string> StrokeColours { get; private set; } = new List<string>();

    /// <summary>
    /// Calculate the drawable that forms the spindle circle
    /// </summary>
    /// <returns>The drawable that makes up the hole
    /// in the middle of the gear</returns>

    private DrawablePath CalculateSpindleCurve()
        => CircularArc.Circle(SpindleDiameter / 2, Coordinate.Empty);

    /// <summary>
    /// Calculate the drawable that forms the inlaid circle
    /// </summary>
    /// <returns>A circular arc for the inlay</returns>

    private DrawablePath CalculateInlayCurve()
        => CircularArc.Circle(InlayDiameter / 2, Coordinate.Empty);
}

