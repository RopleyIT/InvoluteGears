using System;
using System.Collections.Generic;
using System.Linq;
using TwoDimensionLib;

namespace InvoluteGears;

public class Ratchet : IGearProfile
{
    public Ratchet(int teeth, double module, double inner, double cutDiameter)
    {
        ToothCount = teeth;
        Module = module;
        MaxError = 0.0;
        InnerDiameter = inner;
        CutDiameter = cutDiameter;
        Errors = String.Empty;
        Information = SetInformation();
        //CalculatePoints();
    }

    private string SetInformation()
        => $"Ratchet: {ToothCount} teeth, module = {Module}mm\r\n"
            + $"inner diameter = {InnerDiameter}mm\r\n";

    public string ShortName
        => $"Rt{ToothCount}m{Module:N2}i{InnerDiameter:N2}";

    public string Information { get; private set; }

    /// <summary>
    /// Error messages generated by the gear generators. If an
    /// empty string, the gear generation has succeeded and the
    /// other fields will contain data. If non-empty the other
    /// fields may be empty or null.
    /// </summary>

    public string Errors { get; private set; }

    public int ToothCount { get; private set; }

    public double Module { get; private set; }

    public double MaxError { get; private set; }

    public double InnerDiameter { get; private set; }

    public double CutDiameter { get; private set; }

    /// <summary>
    /// The angle occupied by one tooth and one gap
    /// </summary>

    public double ToothAngle => 2 * Math.PI / ToothCount;

    /// <summary>
    /// The pitch circle diameter for a ratchet
    /// wheel is its true diameter to the ends of
    /// the teeth.
    /// </summary>

    public double PitchRadius => Module * ToothCount / 2.0;

    private double ToothDepth => PitchRadius - InnerDiameter / 2;

    private IList<IDrawable> RatchetCurve()
    {
        IList<IDrawable> oneTooth = CalculateOneToothCurve();
        List<IDrawable> ratchetCurve = new();
        for(int i = 0; i < ToothCount; i++)
            foreach(IDrawable p in oneTooth)
                ratchetCurve.Add(p.RotatedBy(i * ToothAngle, Coordinate.Empty));
        return ratchetCurve;
    }

    private IList<IDrawable> CalculateOneToothCurve()
    {
        double innerRadius = InnerDiameter / 2;
        double cutterRadius = CutDiameter / 2;

        // Calculate the cutter centre for the tooth
        // of the ratchet gear at the innermost end

        double m = -ToothDepth / (innerRadius * ToothAngle);
        double xs = Math.Sqrt(cutterRadius * cutterRadius / (1 + m * m));
        double ys = m * xs;
        Coordinate cutterCentre = new(innerRadius + xs, ys);

        // Find the start angle and the end angle for the curve. The curve starts
        // at the X axis and heads towards negative Y. The end angle is where the
        // curve becomes tangential to a radial from the centre of the ratchet.
        // If the cutter centre lies outside the pitch circle, then the ratchet
        // will not be able to have a tooth at right angles to the direction
        // of rotation, and the ratchet is able to skip teeth under high torque.
        // Nonetheless, we calculate the tooth shape and return a warning.

        double radiusOfCutterCentre = cutterCentre.Magnitude;
        double cutterCentreAngle = Math.Asin(-ys / radiusOfCutterCentre);
        double tangentAngle = cutterCentreAngle
            + Math.Asin(cutterRadius / radiusOfCutterCentre);

        double endAngle = Math.PI - Math.Atan2(-ys, xs);
        double startAngle = 3 * Math.PI / 2 - tangentAngle;
        /*
                 double radius = InnerDiameter / 2
            + (PitchRadius - InnerDiameter / 2)
            * angle / ToothAngle;

         */
        List<IDrawable> path = new()
        {
            // Insert the radial face of the ratchet

            new Line
            {
                Start = ArchimedesSpiral
                (ToothAngle - tangentAngle,
                InnerDiameter / 2,
                ToothDepth / ToothAngle).Rotate(-ToothAngle),
                End = cutterCentre + Coordinate
                .FromPolar(cutterRadius, startAngle)
            },

            // Add the the cutter curve

            new CircularArc
            {
                Anticlockwise = false,
                StartAngle = startAngle,
                EndAngle = endAngle,
                Radius = cutterRadius,
                Centre = cutterCentre
            }
        };

        // Check that the radius of the cutter was not too great to
        // provide a latch at right angles to the radial from the centre
        // of the ratchet.

        double actualInnerRadius = cutterCentre.Magnitude - cutterRadius;
        double actualOuterRadius = path[0].Start.Magnitude;
        if (path[0].End.Magnitude > actualOuterRadius)
        {
            Information += "Cutter diameter too great for locking ratchet.\r\n";
            CutDiameter = 0;
            return new List<IDrawable>();
        }
        else
            Information += $"Actual inner diameter: {2 * actualInnerRadius:N2}, "
                + $"actual outer diameter: {2 * actualOuterRadius:N2}\r\n";

        // Now add the slope

        path.AddRange(OneToothSpiral
            (path[1].End.Magnitude, 
            path[0].Start.Magnitude, 
            ToothAngle - tangentAngle));
        return path;
    }


    public DrawableSet GenerateGearCurves()
    {
        return new DrawableSet
        {
            Paths = new List<DrawablePath>
            {
                new DrawablePath
                {
                    Closed = true,
                    Curves = RatchetCurve()
                }
            }
        };
    }

    /// <summary>
    /// Calculate how many splines per tooth to generate when plotting
    /// the ratchet. Settles the maximum range per spline to between
    /// 22.5 and 45 degrees.
    /// </summary>
    /// <param name="angle">The angle we turn through during the
    /// spiral part of the curve. This is slightly less than
    /// ToothAngle, as we have to allow for the cutter diameter.</param>
    /// <returns>Number of splines to draw for each tooth</returns>
    
    private static int AngleSubrangeCount(double angle)
    {
        for (int i = 0; i <= 8; i++)
            if (angle / i < Math.PI / 4)
                return i;
        return 8;
    }

    /// <summary>
    /// Compute the X, Y coordinates of a point on
    /// an Archimedian spiral
    /// </summary>
    /// <param name="angle">The cumulative angle for
    /// which we want the spiral coordinate</param>
    /// <param name="startRadius">The magnitude of
    /// the spiral at angle zero radians</param>
    /// <param name="radiusPerRadian">The rate of
    /// magnitude increase in amplitude per radian
    /// of angl</param>
    /// <returns>The corresponding point on the
    /// spiral</returns>
    
    private static Coordinate ArchimedesSpiral
        (double angle, double startRadius, double radiusPerRadian)
       => Coordinate.FromPolar
                (startRadius + radiusPerRadian * angle, angle);

    private static IList<IDrawable> OneToothSpiral(double rInner, double rOuter, double angle)
    {
        int segments = AngleSubrangeCount(angle);
        List<IDrawable> spiral = new(segments);
        for(int i = 0; i < segments; i++)
        {
            Spline s = new (3, a => ArchimedesSpiral(a, 
                rInner, 
                (rOuter - rInner) / angle), 
                i * angle / segments, 
                (i + 1) * angle / segments);
            spiral.Add(new CubicSpline
            {
                Points = s.ControlPoints
            });
        }
        return spiral;
    }
}
